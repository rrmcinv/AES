// Robert McInvale
// rrm2754
// AES encryption project
// CS 361

#include <iostream>
#include <fstream>
#include <string>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <getopt.h>
#include <stdexcept>
#include <algorithm>
#include <iomanip>

using namespace std;

namespace aes{
  struct word {
  	unsigned char one, two, three, four;
  	word(char firstword, char secondword, char thirdword, char fourthword){
  		one = firstword;
  		two = secondword;
  		three = thirdword;
  		four = fourthword;
  	}
  	word(){}
  };
}

using namespace aes;

const int nb = 4; // number of columns & rows in state per standard

const int s_box[256] =  
 {0x63 ,0x7c ,0x77 ,0x7b ,0xf2 ,0x6b ,0x6f ,0xc5 ,0x30 ,0x01 ,0x67 ,0x2b ,0xfe ,0xd7 ,0xab ,0x76
 ,0xca ,0x82 ,0xc9 ,0x7d ,0xfa ,0x59 ,0x47 ,0xf0 ,0xad ,0xd4 ,0xa2 ,0xaf ,0x9c ,0xa4 ,0x72 ,0xc0
 ,0xb7 ,0xfd ,0x93 ,0x26 ,0x36 ,0x3f ,0xf7 ,0xcc ,0x34 ,0xa5 ,0xe5 ,0xf1 ,0x71 ,0xd8 ,0x31 ,0x15
 ,0x04 ,0xc7 ,0x23 ,0xc3 ,0x18 ,0x96 ,0x05 ,0x9a ,0x07 ,0x12 ,0x80 ,0xe2 ,0xeb ,0x27 ,0xb2 ,0x75
 ,0x09 ,0x83 ,0x2c ,0x1a ,0x1b ,0x6e ,0x5a ,0xa0 ,0x52 ,0x3b ,0xd6 ,0xb3 ,0x29 ,0xe3 ,0x2f ,0x84
 ,0x53 ,0xd1 ,0x00 ,0xed ,0x20 ,0xfc ,0xb1 ,0x5b ,0x6a ,0xcb ,0xbe ,0x39 ,0x4a ,0x4c ,0x58 ,0xcf
 ,0xd0 ,0xef ,0xaa ,0xfb ,0x43 ,0x4d ,0x33 ,0x85 ,0x45 ,0xf9 ,0x02 ,0x7f ,0x50 ,0x3c ,0x9f ,0xa8
 ,0x51 ,0xa3 ,0x40 ,0x8f ,0x92 ,0x9d ,0x38 ,0xf5 ,0xbc ,0xb6 ,0xda ,0x21 ,0x10 ,0xff ,0xf3 ,0xd2
 ,0xcd ,0x0c ,0x13 ,0xec ,0x5f ,0x97 ,0x44 ,0x17 ,0xc4 ,0xa7 ,0x7e ,0x3d ,0x64 ,0x5d ,0x19 ,0x73
 ,0x60 ,0x81 ,0x4f ,0xdc ,0x22 ,0x2a ,0x90 ,0x88 ,0x46 ,0xee ,0xb8 ,0x14 ,0xde ,0x5e ,0x0b ,0xdb
 ,0xe0 ,0x32 ,0x3a ,0x0a ,0x49 ,0x06 ,0x24 ,0x5c ,0xc2 ,0xd3 ,0xac ,0x62 ,0x91 ,0x95 ,0xe4 ,0x79
 ,0xe7 ,0xc8 ,0x37 ,0x6d ,0x8d ,0xd5 ,0x4e ,0xa9 ,0x6c ,0x56 ,0xf4 ,0xea ,0x65 ,0x7a ,0xae ,0x08
 ,0xba ,0x78 ,0x25 ,0x2e ,0x1c ,0xa6 ,0xb4 ,0xc6 ,0xe8 ,0xdd ,0x74 ,0x1f ,0x4b ,0xbd ,0x8b ,0x8a
 ,0x70 ,0x3e ,0xb5 ,0x66 ,0x48 ,0x03 ,0xf6 ,0x0e ,0x61 ,0x35 ,0x57 ,0xb9 ,0x86 ,0xc1 ,0x1d ,0x9e
 ,0xe1 ,0xf8 ,0x98 ,0x11 ,0x69 ,0xd9 ,0x8e ,0x94 ,0x9b ,0x1e ,0x87 ,0xe9 ,0xce ,0x55 ,0x28 ,0xdf
 ,0x8c ,0xa1 ,0x89 ,0x0d ,0xbf ,0xe6 ,0x42 ,0x68 ,0x41 ,0x99 ,0x2d ,0x0f ,0xb0 ,0x54 ,0xbb ,0x16};
 
 const int inverse_s_box[256] =
 {0x52 ,0x09 ,0x6a ,0xd5 ,0x30 ,0x36 ,0xa5 ,0x38 ,0xbf ,0x40 ,0xa3 ,0x9e ,0x81 ,0xf3 ,0xd7 ,0xfb
 ,0x7c ,0xe3 ,0x39 ,0x82 ,0x9b ,0x2f ,0xff ,0x87 ,0x34 ,0x8e ,0x43 ,0x44 ,0xc4 ,0xde ,0xe9 ,0xcb
 ,0x54 ,0x7b ,0x94 ,0x32 ,0xa6 ,0xc2 ,0x23 ,0x3d ,0xee ,0x4c ,0x95 ,0x0b ,0x42 ,0xfa ,0xc3 ,0x4e
 ,0x08 ,0x2e ,0xa1 ,0x66 ,0x28 ,0xd9 ,0x24 ,0xb2 ,0x76 ,0x5b ,0xa2 ,0x49 ,0x6d ,0x8b ,0xd1 ,0x25
 ,0x72 ,0xf8 ,0xf6 ,0x64 ,0x86 ,0x68 ,0x98 ,0x16 ,0xd4 ,0xa4 ,0x5c ,0xcc ,0x5d ,0x65 ,0xb6 ,0x92
 ,0x6c ,0x70 ,0x48 ,0x50 ,0xfd ,0xed ,0xb9 ,0xda ,0x5e ,0x15 ,0x46 ,0x57 ,0xa7 ,0x8d ,0x9d ,0x84
 ,0x90 ,0xd8 ,0xab ,0x00 ,0x8c ,0xbc ,0xd3 ,0x0a ,0xf7 ,0xe4 ,0x58 ,0x05 ,0xb8 ,0xb3 ,0x45 ,0x06
 ,0xd0 ,0x2c ,0x1e ,0x8f ,0xca ,0x3f ,0x0f ,0x02 ,0xc1 ,0xaf ,0xbd ,0x03 ,0x01 ,0x13 ,0x8a ,0x6b
 ,0x3a ,0x91 ,0x11 ,0x41 ,0x4f ,0x67 ,0xdc ,0xea ,0x97 ,0xf2 ,0xcf ,0xce ,0xf0 ,0xb4 ,0xe6 ,0x73
 ,0x96 ,0xac ,0x74 ,0x22 ,0xe7 ,0xad ,0x35 ,0x85 ,0xe2 ,0xf9 ,0x37 ,0xe8 ,0x1c ,0x75 ,0xdf ,0x6e
 ,0x47 ,0xf1 ,0x1a ,0x71 ,0x1d ,0x29 ,0xc5 ,0x89 ,0x6f ,0xb7 ,0x62 ,0x0e ,0xaa ,0x18 ,0xbe ,0x1b
 ,0xfc ,0x56 ,0x3e ,0x4b ,0xc6 ,0xd2 ,0x79 ,0x20 ,0x9a ,0xdb ,0xc0 ,0xfe ,0x78 ,0xcd ,0x5a ,0xf4
 ,0x1f ,0xdd ,0xa8 ,0x33 ,0x88 ,0x07 ,0xc7 ,0x31 ,0xb1 ,0x12 ,0x10 ,0x59 ,0x27 ,0x80 ,0xec ,0x5f
 ,0x60 ,0x51 ,0x7f ,0xa9 ,0x19 ,0xb5 ,0x4a ,0x0d ,0x2d ,0xe5 ,0x7a ,0x9f ,0x93 ,0xc9 ,0x9c ,0xef
 ,0xa0 ,0xe0 ,0x3b ,0x4d ,0xae ,0x2a ,0xf5 ,0xb0 ,0xc8 ,0xeb ,0xbb ,0x3c ,0x83 ,0x53 ,0x99 ,0x61
 ,0x17 ,0x2b ,0x04 ,0x7e ,0xba ,0x77 ,0xd6 ,0x26 ,0xe1 ,0x69 ,0x14 ,0x63 ,0x55 ,0x21 ,0x0c ,0x7d};
 
 const int mul2[256] = {
	0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,
	0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e,
	0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,
	0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e,
	0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e,
	0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,
	0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,
	0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe,
	0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05,
	0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25,
	0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45,
	0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65,
	0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85,
	0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5,
	0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5,
	0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5,
};

const int mul3[256]={
	0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11,
	0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21,
	0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71,
	0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41,
	0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1,
	0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1,
	0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1,
	0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81,
	0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a,
	0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba,
	0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea,
	0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda,
	0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a,
	0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a,
	0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a,
	0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a,
};

const int mul9[256] ={
	0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77,
	0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7,
	0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c,
	0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc,
	0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01,
	0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91,
	0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a,
	0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa,
	0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b,
	0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b,
	0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0,
	0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30,
	0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed,
	0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d,
	0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6,
	0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46,
};

const int mul11[256] = {
	0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69,
	0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9,
	0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12,
	0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2,
	0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f,
	0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f,
	0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4,
	0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c, 0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54,
	0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e,
	0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e,
	0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5,
	0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55,
	0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68,
	0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8,
	0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13,
	0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3,
};

const int mul13[256]= {
	0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b,
	0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b,
	0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0,
	0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20,
	0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26,
	0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6,
	0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d,
	0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d,
	0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91,
	0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41,
	0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a,
	0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa,
	0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc,
	0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c,
	0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47,
	0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97,
};

const int mul14[256] = {
	0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a,
	0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba,
	0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81,
	0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61,
	0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7,
	0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17,
	0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c,
	0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc,
	0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b,
	0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb,
	0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0,
	0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20,
	0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6,
	0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56,
	0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d,
	0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d,
};
 
 const word rcon[11] =
 { word(0,0,0,0),
 word(0x01, 0, 0, 0),
 word(0x02, 0, 0, 0),
 word(0x04, 0, 0, 0),
 word(0x08, 0, 0, 0),
 word(0x10, 0, 0, 0),
 word(0x20, 0, 0, 0),
 word(0x40, 0, 0, 0),
 word(0x80, 0, 0, 0),
 word(0x1b, 0, 0, 0),
 word(0x36, 0, 0, 0)
 };

ostream& operator<< (ostream &os, const word& w){
	os << hex << setw(2) << setfill('0') << (int)w.one << setw(2) << setfill('0') << (int)w.two << setw(2) << setfill('0') << (int)w.three << setw(2) << setfill('0') << (int)w.four;
	return os;
}

namespace aes {
  
  // mostly for debug purposes
  void print_data(char* data, int size, int start = 0){
  	for(int i = start; i < (start + size); i++){
  		unsigned char c = data[i];
    	cout << hex << setw(2) << setfill('0') << (int)c << " ";
    }
    cout << endl;
  }
  
  void print_state(char** state){
  	for(int row = 0; row < 4; row++){
  		for(int col = 0; col < nb; col++){
  			unsigned char c = state[row][col];
  			cout << hex << setw(2) << setfill('0') << (int)c << " ";
  		}
  			cout << endl;
  	}
  	cout << endl;
  }
  
  void print_words(word* words, int size){
  	for (int i = 0; i < size; i++){
  		cout << words[i];
  		if (i%6 == 0) 
  			cout << endl;
  		cout << " ";
  	}
  	cout << endl;
  }
  
  // pad input using CMS method
  void pad(char* bytes, int &size){
    int needed_bytes = 16 - size % 16;
    for (int i = size; i < (size + needed_bytes); i++){
    	bytes[i] = needed_bytes;
    }
		size += needed_bytes;
  }
	
	void get_state(char** state, char* input, int start_index){
		for (int col = 0; col < nb; col++){
			for (int row = 0; row < 4; row++){
				state[row][col] = input[start_index + row + 4*col];
			}
		}
	}
	
	void get_state(char** state, word* words, int start_index){
		for (int col = 0; col < nb; col++){
			state[0][col] = words[start_index + col].one;
			state[1][col] = words[start_index + col].two;
			state[2][col] = words[start_index + col].three;
			state[3][col] = words[start_index + col].four;
		}
	}
	
	void read_state(char** state, char* output, int start_index){
		for (int col = 0; col < nb; col++){
			for (int row = 0; row < nb; row++){
				output[start_index + row + 4*col] = state[row][col];
			}
		}
	}
	
	char get_high_nibble(char c){
		return (((1 << 4) - 1) & c);
	}
	
	char get_low_nibble(char c){
		return (((1 << 4) - 1) & (c >> 4));
	}
	
	char sub_byte(char byte){
		unsigned char c = byte;
		//cout << hex << "byte: " << int(c) << endl;
		unsigned char high_nibble = get_low_nibble(byte);
		unsigned char low_nibble = get_high_nibble(byte);
		//cout << hex << "read " << int(high_nibble) << " " << int(low_nibble) << endl;
		return s_box[high_nibble*16 + low_nibble];
	}
	
	void sub_bytes(char** state){
		cout << "sub_bytes" << endl;
		for (int col = 0; col < nb; col++){
			for (int row = 0; row < 4; row++){
				state[row][col] = sub_byte(state[row][col]);
			}
		}
	}
	
	word sub_word(word w){
		word result;
		result.one = sub_byte(w.one);
		result.two = sub_byte(w.two);
		result.three = sub_byte(w.three);
		result.four = sub_byte(w.four);
		//cout << "subWord: " << result << " ";
		return result;
	}
	
	word xor_words(word a, word b){
		word result;
		result.one = a.one^b.one;
		result.two = a.two^b.two;
		result.three = a.three^b.three;
		result.four = a.four^b.four;
		//cout << "xorWord: " << result << " ";
		return result;
	}
	
	word rot_word(word w){
		word result;
		result.four = w.one;
		result.three = w.four;
		result.two = w.three;
		result.one = w.two;
		//cout << "rotWord: " << result << " ";
		return result;
	}
	
	void key_expansion(char* key, word* words, int nk, int words_length){
		for (int i = 0; i < nk; i++){
			words[i] = word(key[4*i], key[4*i + 1], key[4*i + 2], key[4*i + 3]);
		}
		
		word temp;
		for (int i = nk; i < words_length; i++){
			temp = words[i-1];
			//cout << "temp: " << temp << " ";
			if (i % nk == 0){
				//cout << "rcon[i/nk]: " << rcon[i/nk] << " ";
				temp = xor_words(sub_word(rot_word(temp)), rcon[i/nk]);
			}
			else if ((nk > 6) && ((i%nk) == 4)) {
				temp = sub_word(temp);
			}
			//cout << "w[i-nk]: " << words[i-nk] << " ";
			words[i] = xor_words(words[i-nk], temp);
			//cout << endl;
		}
	}
	
	char add(char a, char b){
		return a^b;
	}
	
	char multiply(int a, char b){
		
		// get the appropriate lookup table
		const int* table;
		if (a == 2)
			table = mul2;
		else if (a == 3)
			table = mul3;
		else if (a == 9)
			table = mul9;
		else if (a == 11)
			table = mul11;
		else if (a == 13)
			table = mul13;
		else if (a == 14)
			table = mul14;
		else {
			cout << "invalid multiplication coefficient" << endl;
			return 0;
		}
		
		return table[get_high_nibble(b) + get_low_nibble(b)*16];
	}
	
	char** make_state(int cols){
		char** state = new char*[4];
		for(int row = 0; row < 4; row++){
			state[row] = new char[cols];
		}
		return state;
	}
	
	void add_round_key(char** state, word* words, int round){
		cout << "add_round_key" << endl;
		const int l = round*nb; 
		for (int col = 0; col < nb; col++){
			state[0][col] = add(state[0][col], words[l+col].one);
			state[1][col] = add(state[1][col], words[l+col].two);
			state[2][col] = add(state[2][col], words[l+col].three);
			state[3][col] = add(state[3][col], words[l+col].four);
		}
	}
	
	void shift_rows(char** state){
		cout << "shift_rows" << endl;
		for (int row = 1; row < 4; row++){
			char new_vals[nb];
			for (int col = 0; col < nb; col++){
				new_vals[col] = state[row][(col + row)%nb];
			}
			for (int col = 0; col < nb; col++){
				state[row][col] = new_vals[col];
			} 
		}
	}
	
	void mix_columns(char** state){
		cout << "mix_columns" << endl;
		for (int col = 0; col < nb; col++){
			char result[4]; // 4 rows
			result[0] = add(
										add( 
											add(multiply(2, state[0][col]), 
													multiply(3, state[1][col])) 
											,state[2][col]), 
										state[3][col]);
			result[1] = add(
										add( 
											add(state[0][col], 
													multiply(2, state[1][col])),
											multiply(3, state[2][col])),
										state[3][col]);
			result[2] = add(
										add(
											add(state[0][col], state[1][col]),
											multiply(2, state[2][col])), 
										multiply(3, state[3][col]));
			result[3] = add(
										add(
											add(multiply(3, state[0][col]), state[1][col]),
											state[2][col]), 
										multiply(2, state[3][col]));
			
			for (int row = 0; row < 4; row++){
				state[row][col] = result[row];
			}
		}
	}
	
	
	void encrypt_cipher(char** in_state, char* raw_input, char** out_state, char* raw_output, int offset, word* key_words, int nr){
    get_state(in_state, raw_input, offset);
    print_state(in_state);
    
    // start actual cipher
    add_round_key(in_state, key_words, 0);
    print_state(in_state);
    
    for (int round = 1; round < nr; round++){
    	cout << "round " << round << endl;
    	sub_bytes(in_state);
    	print_state(in_state);
    	shift_rows(in_state);
    	print_state(in_state);
    	mix_columns(in_state);
    	print_state(in_state);
    	add_round_key(in_state, key_words, round);
    	print_state(in_state);
    }
    cout << "round " << nr << endl;
    sub_bytes(in_state);
    print_state(in_state);
    shift_rows(in_state);
    print_state(in_state);
    add_round_key(in_state, key_words, nr);
    print_state(in_state);
    
    // output
    read_state(in_state, raw_output, offset);
	}
	
  void encrypt(char* raw_input, char* raw_key, char* raw_output, int key_size, int input_size){
    pad(raw_input, input_size); // pad the input appropriately
    
    const int word_size = 32; // 4 bytes
    const int nk = key_size/word_size; // standard variable, words in the key
    const int nr = nk + 6; // standard variable, should be either 10 or 14 depending on key_size; number of rounds
    
    if (input_size % 16 != 0 || input_size == 0){
    	cout << "padding size error" << endl;
    	return;
    }
    	
    // set up our state arrays

  	
  	// get our key expansion (word array)
  	const int expanded_key_size = nb*(nr+1);
  	word* key_word_array = new word[expanded_key_size]; // each word is 4 bytes
    key_expansion(raw_key, key_word_array, nk, nb*(nr+1));
    print_words(key_word_array, expanded_key_size);
    

    char** in_state = make_state(nb);
  	char** out_state = make_state(nb);
    // set up main cipher loop
    for (int i = 0; i < input_size; i += 16){	
		  encrypt_cipher(in_state, raw_input, out_state, raw_output, i, key_word_array, nr);
    }
  }
  
  void decrypt(char* raw_input, char* raw_key, char* raw_output, int key_size, int input_size){
    
  }
  
} // end namespace

int main (int argc, char *argv[]){
	int key_size = -1;
	int input_size = -1;
	string key_file = "";
	string input_file = "";
	string output_file = "";
	string mode = "";

	// parse arguments
	int option;
	while (1) {
		int this_option_optind = optind ? optind : 1;
		int option_index = 0;
		static struct option long_options[] = {
			{"keysize",     required_argument, 0,  0 },
			{"keyfile",  required_argument,       0,  0 },
			{"inputfile",  required_argument, 0,  0 },
			{"outputfile", required_argument,       0,  0 },
			{"mode",  required_argument, 0, 0},
			{0,         0,                 0,  0 }
		};

		option = getopt_long_only(argc, argv, "", long_options, &option_index);
		if (option == -1)
			break;
		switch (option) {
		case 0:
			switch (option_index){
				case 0:
					try {
						key_size = stoi(optarg);
						if (key_size != 128 && key_size != 256) 
							throw invalid_argument("wrong # of bits");
					}
					catch (...){
						cout << "error reading keysize; must be 128 or 256." << endl;
						return 1;
					}
					break;
				case 1:
					key_file = optarg;
					break;
				case 2:
					input_file = optarg;
					break;
				case 3:
					output_file = optarg;
					break;
				case 4:
					mode = optarg;
					transform(mode.begin(), mode.end(), mode.begin(), ::tolower);
					if (mode != "encrypt" && mode != "decrypt"){
						cout << "invalid mode, must be encrypt or decrypt." << endl;
						return 1;
					}
					break;
			}
			break;
		case '?':
			break;
		default:
			printf("?? getopt returned character code 0%o ??\n", option);
		}
	}

	if (optind < argc) {
		printf("non-option ARGV-elements: ");
		while (optind < argc)
			printf("%s ", argv[optind++]);
		printf("\n");
	}

	// see if they used all flags	
	if (key_size == -1 || key_file == "" || input_file == "" || output_file == "" || mode == ""){
		cout << "Usage: ./aes --keysize <128|256> --keyfile <key file name> --inputfile <input file name> --outputfile <output file name> --mode <encrypt|decrypt>" << endl;
		return 1;	
	}

	// attempt to open files
	ifstream key_file_stream, input_file_stream;
	ofstream output_file_stream;

	// open key
	key_file_stream.open(key_file, ios::in|ios::binary|ios::ate); // open at end of file in binary read mode
	if (!key_file_stream.is_open()){
		cout << " failed to open key file" << endl;
		return 1;	
	}
	
	cout << "seen key size: " << key_file_stream.tellg() << " bytes" << endl;
	if (key_file_stream.tellg() != key_size/8){
		cout << "key size mismatch, expected " << key_size << " bits, got " << key_file_stream.tellg() * 8 << " bits." << endl;
		return 1;
	}
	
	key_file_stream.seekg(0, key_file_stream.beg); // go back to start of file

	// open input file
	input_file_stream.open(input_file, ios::in|ios::binary|ios::ate); // end of file, binary read mode
	if (!input_file_stream.is_open()){
		cout << " failed to open input file" << endl;
		return 1;
	}
	
	input_size = input_file_stream.tellg();
	cout << "seen input size: " << input_size << " bytes" << endl;
	input_file_stream.seekg(0, input_file_stream.beg); // go back to start of file

	// open output file
	output_file_stream.open(output_file, ios::out|ios::binary); // binary write mode
	if (!output_file_stream.is_open()){
		cout << " failed to open output file" << endl;
		return 1;
	}

  // done opening, store data
  char* raw_key = new char[key_size/8];
  char* raw_input;
  char* raw_output;
  
  key_file_stream.read(raw_key, key_size/8);

  
  // done storing data, call primary functions
	
	if (mode == "encrypt"){
		raw_input = new char[input_size/16 + 16]; // add extra space for the padding
		raw_output = new char[input_size/16 + 16]; 
		input_file_stream.read(raw_input, input_size); 
	  encrypt(raw_input, raw_key, raw_output, key_size, input_size);
	  }
	else if (mode == "decrypt"){
		raw_input = new char[input_size];
		raw_output = new char[input_size]; 
		input_file_stream.read(raw_input, input_size); 
	  decrypt(raw_input, raw_key, raw_output, key_size, input_size);
	}
	
	input_file_stream.close();
	key_file_stream.close();
	output_file_stream.close();


	return 0;
}


